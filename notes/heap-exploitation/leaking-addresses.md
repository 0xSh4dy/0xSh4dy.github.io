---
layout: page
title: Leaks
comments: true
tags: [leak,calloc,IS_MMAPED]
---

Now, let's discuss various techniques used to leak libc, ELF and heap addresses in a typical heap exploitation CTF challenge.

## calloc
```
void *calloc(size_t nmemb, size_t size);
```
According to Linux man pages,
The calloc() function allocates memory for an array of `nmemb` elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. If `nmemb` or size is 0, then calloc() returns either NULL, or a unique pointer value that can later be successfully passed to free(). One important thing to notice is that unlike malloc, calloc zeroes out the allocated memory.

The following code snippet is present in all versions of libc (malloc.c) till libc-2.35 (including it).
```
#define IS_MMAPPED 0x2

......

void *__libc_calloc (size_t n, size_t elem_size)
{
	....
	  if (chunk_is_mmapped (p))
    {
      if (__builtin_expect (perturb_byte, 0))
        return memset (mem, 0, sz);

      return mem;
    }
    ....

}

```
It is clearly visible that if the `IS_MMAPPED` bit is set, calloc will not zero out the chunk. Thus, a libc address can be leaked by first inserting a chunk into the unsorted bin, setting its `IS_MMAPPED` flag, allocating it from the unsorted bin and then reading its data.

Note: One important thing to note down is that `calloc` does not allocate from the `tcache`.

